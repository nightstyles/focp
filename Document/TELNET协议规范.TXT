　
TELNET协议规范

ARPA Internet上的主机被要求采用并实现此标准。

　　

介绍

TELNET Protocol的目的是提供一个相对通用的，双向的，面向八位字节的通信方法。它主要的目标是允许接口终端设备的标准方法和面向终端的相互作用。可以预见到，此协议也可被用于终端到终端的通信和处理到处理的通信（分布式计算）。
　

一般考虑

一个TELNET连接是一个用于传输控制协议的传送数据的。TELNET 协议是建立在以下三个想法上的：首先是网络虚拟终端的概念；其次是对话选项的方法；最后是终端和处理的协调。
　

当一个TELNET连接被初次建立时，每一端都被假设使用了网络虚拟终端，也就是NVT。NVT是一个想象中的标准设备通用设备的代表。这就消除了“服务器”和“用户”机要了解对方机器终端的特点，而终端可以直接处理对话。所有的主机，用户端的和服务器端的，它们自己本地的设备特点因此在网络上可以作为一种NVT处理，任何一个都可以认为对方使用的是相同特点的设备。NVT倾向于不过多地限制（提供了一个相应比较丰富的映射到本地设备的字符集），也不是包括一切的（它要求用户使用适当的终端）。注意：用户机通常是与处理终端连接的主机，服务器机通常是提供某种服务的机器。从另一点看，在终端到终端或进程到进程的通信上，用户机是发起通信的机器。 
规定选项的原理将以下事实考虑在内，许多机器希望在现在的NVT上提供另外的服务，多数用户有比较复杂的终端，它们也就希望一种比较完整的而不是最小的服务。独立的，但是存在于 TELNET 协议的不同选项支持这些需求，它们使用"DO, DON'T, WILL, WON'T" 结构允许用户机和服务器建立建立一种更加精巧的TELNET会话连接。这种选项包括改变字符集，响应模式等等。设置选项的基本策略是任一方（或者两者）初始化要求一个选项生效的请求。另一方可以接受也可以拒绝这一请求。如果接受请求，此选项立刻生效；如果被拒绝，连接仍然保持基本的NVT的连接属性。很明显，一方可以拒绝另一方关于启用某一选项的请求，但是不能拒绝另一方关于使一选项失效的请求，因为双方必须准备支持NVT。对话选项语法的建立使在双方都发出请求某一选项生效的请求时，另一方可以直接认为收到对方的确认信息。 
这种对称式的对话语法潜在地引起了一个不可终止的确认环--任何一方都将收到的确认信息看作是请求，而不是一个确认信息。为了防止这种循环的出现，有下面的规则： 
任何一方仅可以要求对选项状态的变化：例如，一方不可以发出请求，仅仅说明它在什么样的选项状态下。 
如果一方接收到好象是请求的信息，请求进入一个已经进入的状态，此信息将被看作是一个确认消息。这种非响应从本质上防止了不可终止的对话的循环。如果要求发送一个要求改变状态的请求，即使状态并未改变。 
无论何时，一方发送选项命令到另一方，无论作为一个请求或者是一个确认消息，选项的使用将对发送的数据处理有影响，这样命令应该被插入到希望发生作用的数据流中的数据点之前。（应该注意，传送请求和收到确认消息之间有一定的时间间隔，这是被动方式的。因此，一个主机希望在要求一个选项后缓存数据，直到它知道它的请求是否被接受，这样就可以使这段不不确定时间对用户不可见。）选项的请求可以在建立TELNET连接时十分频繁地来往交换，因为每一方都希望从对方得到更好的服务。 
除此以外，选项也可以在连接持续过程中动态改变来适应本地机器条件的变化。例如，NVT（它将以后被详细解释）对于许多“一次一行”的应用程序，如BASIC是十分适用的，而对于如NLS的“一次一字”的应用程序却不怎么好用。服务器可能被选择作为“一次一字”法则来适应在其上运行的本地进程，它将发起对话以达到合适的选项状态。然而，相对于永久地负责这种多余的处理负担；它可以通过会话，在不需要这样的选项状态下回到NVT状态。由一个进程发起的请求可以导致一个不可终止的请求循环，如果此进程对一个拒绝请求的响应是再次要求此选项。为了防止这样循环的发生，被拒绝的请求在其它事情发生变化之前不能被重复请求。这可能意味着，进程运行另外一个程序，或者用户发送另外的命令，或者用户对于环境或选项的改变。

比较好的方法是，预请求应该作为由另一端发送信息的结果而发生，或者由于人为介入而发生。选项的设计者不应该因为对于选项会话的种种限制而感觉到伸不开手脚。一般语法的目的是更容易地拥有选项--因为表示对它们的忽视也是容易的。

如果特定的选项需要除"DO, DON'T, WILL, WON'T"以外的更丰富的结构，正确的方针是使用"DO, DON'T, WILL, WON'T"来建立连接解释这种新结构，当这一解释工作完成时，就可以自由地使用这一新结构了。例如，一方可能发送请求改变（或建立）每行的长度。如果接受了这些，对于对话的不同行长度可以使用不同的语法来表示--“子对话”可以包括一个域表示最大允许的，最小允许的和希望的长度。重要概念是这样的扩充的会话应该直到双方建立了标准的会话并且能够解释这种扩充的语法之后再进行。总的来说，WILL XXX发送时说明一方希望执行选项XXX，DO XXX 和 DON'T XXX作为确定的不确定的响应；同样，DO XXX被作为一种请求发送给另一方来启动选项XXX，WILL XXX 和WON'T将被作为确定和不确定的响应。因为NVT是没有任何选项时的结果， DON'T和WON'T响应将保证使连接最终保持于这种没有任何选项的状态。因此，所有主机可以不支持不理解的选项，它仅仅需要返回这种选项的请求即可。

尽可能的，TELNET协议被用作服务器-用户的对称，这样，它就可以更容易而自然地处理用户-用户和服务器-服务器的情况。用选项来扩展这一功能是被希望实现的，但不是必要的。在任何情况下，对称是一个运行的准则而不是固定的准则多次被明确提出。一个比较文档，“TELNET选项说明”，可以被用于对建立新选项过程信息的参考。

网络虚拟终端网络虚拟终端（NVT）是一个双向字符设备。NVT有一个显示设备和一个键盘。显示设备响应到达的数据，键盘负责通过TELNET连接发送数据，如果需要回显，也应该在NVT的显示设备上显示。对于网络上的回显并不要求（虽然确实存在这个“远程”回显选项，但是主机必不是必须实现此选项）。字符集是由七位ASCII码组成的，而保存在八位的域中。任何字符的转换和计时方面的考虑都是本地的问题，这不影响NVT的工作。

数据传送方面，虽然TELNET连接是全双工的，NVT却是在线缓冲状态下的半双工设备。传送数据 虽然TELNET连接是全双工的，在线缓冲模式下，NVT却被当作半双工的设备。此信号可以由进程或者用户产生。对于一些主机处理网络输入中断，或与默认的不进行远程回显的NVT说明的主机来说，此规则的代价是高昂的。因此，在源点缓存一些数据是有理由的。一些系统在每个输入行未采用一些操作（即使是行打印机或打卡机也经常采用这种方法），这样可以在每行未开始发送。在另一方面，用户或者进程可以有时发觉提供在行未不中断的数据是有用的而且是必须的；因此，也应该在实现在本地能够识别这种信号并把这些数据立刻发送的方法和机制。当一个进程已经完成将数据发送到对方的显示设备而且也没有缓存的输入数据时时，进程必须发送TELNET Go Ahead (GA)命令。

这个规则并不是要求 TELNET GA命令必须由双方终端发送，因为服务器主机通常不要求特定的信号来继续进程。但是，此命令的设计可以帮助用户的本地主机操作一个物理上半双工的终端，它如果IBM2741一样拥有可锁定的键盘。对此种类型终端的描述有助于解释GA命令的正确使用。终端和计算机的连接总是在计算机或用户的控制之下。任何一方都不能够隐式地从另一方获得控制权；控制权必须显式地从一方转移到另一方。

在终端一方，设置硬件在每一行结束时放弃控制权（例如，当用户按下回车键时）。当这种情况发生时，本地计算机处理输入数据，决定是否输出，如果不需要，将控制权回送给终端。如果需要产生输出，计算机将保有控制权直到输出数据发送完毕。在网络上使用这种终端的困难是显而易见的。“本地”计算机不知道在读到行未符号时是否应该继续保持控制权；这个问题的决定权在远地处理此数据的计算机。因此，TELNET GA命令提供了一种机制让远程计算机能够通知本地计算机，让它将控制权转交给用户终端。在用户需要控制权时，此信号应该也只能在此时发送。注意：过早地发送GA命令会使输出数据阻塞，因为用户可以假定传送系统暂停，因此不能将一行结束。当然，前述内容不能够用于用户到服务器方面的通信方面。在这个方面，GA命令可以在任何时候发送，可以根本不用发送。同样，如果TELNET连接被用于进程到进程的通信，也不需要发送GA命令。

最后，对于终端到终端的通信，可以在两端都需要GA命令，也可以在一端，也可以两端都需要。如果主机希望支持终端到终端的通信主机应该提供一种让用户自由发送GA命令的方法；然而，对于一个TELNET进程而言，这并不是必须的。注意：TELNET模式的对称性要求在概念上，两端中的一端至少是一个NVT。控制函数的标准表示 如要本文的介绍中所说的，TELNET协议的目的是提供一种网络上面向终端进程和终端设备的标准接口。

这种类型互连的先前的经验告诉我们，在许多主机上已经实现了类似的功能，但它们的实现方法却差别很大。对于接触这些系统的用户而言，这些差别将是令人头痛的。因此，TELNET定义了以下功能的五种标准表示。这种标准表示有一定的标准的意义，但这也不是必须的（例外是中断处理函功能要其它使用TELNET的协议执行）；这也就是说，系统不提供给本地用户的功能也不可以不提供给远程用户，它可以将标准表示作为非操作的功能。

在另一方面，给本地用户提供此功能的系统必须也向传送此功能标准表示的远程用户提供此功能。

中断处理（IP）一些系统提供可以暂停，中断，放弃或终止用户进程操作的功能。当用户确定它的进程处于不可结束的循环中，或不经意地激活了一个进程时经常使用此功能。IP是使用此功能的标准表示。实现者应该注意的是：使用TELNET的其它协议可能也需要IP，因此，如果需要支持其它协议就应该实现IP。放弃输出 (AO) 许多系统提供此功能，它允许产生输出的进程到达类似操作结束的点，而不将输出发送到用户的终端。更深一层的，此功能通常清除已产生的所有输出，而不显示到用户的终端上。AO是使用此功能的标准表示。

例如，一些子系统可能通常接受用户命令，发送长文本串到用户终端，最后发送一个提示用户允许接收下一命令的提示符到用户终端。如果在传送文本串的过程中接收到AO命令，将会不再发送剩余的字符串，而直接显示提示符告知用户可以输入下一命令。（这与接收到IP之后的操作可能有所不同；IP会放弃发送剩余的字符串而且退出子系统。）应该注意到，使用提供此功能的服务器系统时外部缓冲区（在网络和用户本地主机上）也被清除；完成的正确方法是向用户系统发送“Synch”信号。

你在此吗 （AYT） 许多系统提供用户这样的功能，让用户知道是否正在运行。此功能在系统由于不可预知长度运算，或系统负载重的情况下长时间不响应时由用户发起。AYT是使用此功能的标准表示。

删除字符（EC） 许多系统提供此功能用于删除最近相邻的不可删除字符或用户提供数据流的最近相邻的“显示位置”。此功能通常用于编辑键盘错误的输入。EC是使用此功能的标准表示。注意：“显示位置”可能包括多于一个的字符，它们是过多键入的结果或者如下格式的字符串：<char1> BS <char2>...

删除行（EL） 许多系统提供此功能用于删除当前输入行中的所有数据。此功能通常被用于是编辑键盘输入。EL是使用此功能的标准表示。

TELNET的"Synch"信号 大部分时分系统提供一种允许终端用户重新获得失控进程的机制；上述的IP和AO功能就是此机制的一个例子。这些系统，当被用于本地时，访问由用户提供的所有信号，无论此信号是一般字符还是不可显示的字符如电传中的“BREAK”或IBM 2741中的“ATTN”键。当系统通过网络连接时这种情况不一定就是准确的；网络流量控制机制可能导致一个信号被缓存于网络中某处，例如在用户的主机中。为了克服这个问题，引入了TELNET的“Synch”机制。一个Synch信号包括一个TCP 紧急信号和TELNET命令 DATA MARK。

紧急信号，它不受限于限制TELNET的流量控制，它可以在接收到进程引发特定的数据处理。

在这种模式中，此数据流立即被看作是“有重大意义的”，而抛弃其它数据。

TELNET命令DATA MARK (DM)是数据流中的同步标志，它指示任何特定的信号已经发生过了，接收可以返回到正常处理其它数据的状态中了。Synch通过TCP发送操作完成，它和紧急标志及在最后的DM标志一起发送。当一些Synch信号被连续快速发送时紧急信号可能被淹没。不可能对紧急信号记数，因为这一数字有可能小于也可能等于已经发送的数目。当处于通常模式下，DM不是一个操作；当处于紧急模型下，它指示紧急处理的结束。如果TCP指示紧急数据结束前发现DM，TELNET应该继续操作数据流直到遇到DM为止。如果TCP在DM之后指示又有一些紧急数据，那只能是因为是一串Synch。TELNET应该继续操作数据流直到遇到DM。

“有意义的”信号被定义为：IP，AO和AYT（但不是EC或EL）的TELNET标准定义；如果有的话，本地对这些标准定义的模拟；所有其它TELNET命令；其它站点定义的不需要拖后数据流的信号。因为SYNCH命令的另一个作用是抛弃所有在接收者和发送者之间随了TELNET命令之外的字符，如果需要时，此机制被指定为标准方法来清理数据路径。例如，如果一个在终端的用户传送一个AO命令，收到此命令的服务器（如果此服务器提供此功能）应该返回一个SYNCH给用户。

最后，正如需要TCP紧急信号作为供他们使用的命令一样，其它使用TELNET协议的协议也需要类似的命令。这通过使用[IP，SYNCH]就可以达到。例如，假设其它一些使用TELNET的协议定义了类型于AO命令的停止字符串。试想此协议的用户希望服务器来处理停止字符串，但连接因为服务器正在处理别的命令而被阻塞。用户应该使它的系统做以上工作：

发送TELNET IP字符； 
发送TELNET SYNC串，这就是说：发送DM作为在TCP紧急模式发送操作下的唯一字符串。 
发送字符串STOP，并且 
发送其它协议的类型于TELNET DM的命令。 
用户（或者进程）必须象步2一样重新发送TELNET SYNCH序列来确保TELNET IP到达服务器的TELNET解释器。“紧急”将唤醒TELNET进程；IP应该唤醒更高级的进程。NVT显示和键盘 NVT显示有一个未指定的行宽和页面大小，并且可以产生代表ASCII码的字符。

对于33个控制字符和另外128个没有使用的字符，将指定给显示： 

NULL (NUL) 0 无操作；

Line Feed (LF) 10 将显示移动到下一行的同一垂直位置。

Carriage Return (CR) 13 将显示移至当前行的左边界处。

另外，还应该定义如下字符（但这不是必须的），它们对显示也有作用。TELNET的任何一方都不会假定另一方会在接收或传送时采取以下行动：

BELL (BEL) 7 响铃或者给出一个可视的信号（这并不移动显示位置）。

Back Space (BS) 8将显示向左移一个位置。

Horizontal Tab (HT) 9 将显示移至下一个制表位。现在还未指定任何一方如何决定制表位的位置究竟在什么地方。

Horizontal Tab (HT) 9 将显示移至下一个垂直制表位。现在还未指定任何一方如何决定制表位的位置究竟在什么地方。

Form Feed (FF) 12 将显示移动到下页起始位置，并保持相同的水平位置。所有现在的代码都不使NVT显示作任何操作。

CR LF序列将使显示定位于下一显示行的左边界处。然而，许多系统和终端并不将这两个字符分开处理而不得不作一些工作模拟它们的作用。（例如，一些终端没有独立于LF的CR，但在这些终端上可以通过后退键模拟CR的功能。）因此，CR LF序列必将作为新行标记使用它们的复合功能；CR NUL必须在希望仅输入一个回车时使用；在其它情况下应该避免单独使用CR。这个法则使必须决定是否进行一个“新行”操作功能或多个回退的系统能够保证包括由一个字符在CR后面的TELNET流的操作，并作出正确的决定。注意：CR LF或者CR NUL对双方都是要求的，这就保证了NVT的对称性。即使在一些情况下可以知道字符未被送到实际的终端，然而，出于一致性的考虑，协议要求在CR后面如果没有LF就必须插入一个NUL。反过来说，在CR后面接收到一个NUL后，应该把它从数据流中抛弃，而不应该将它用于NVT的字符映射。

在NVT上有键盘，组合键或键序列来产生这全部128个字符。注意：虽然其中的一些对NVT显示没有作用，NVT也有能力产生它们。除了这些以外，NVT键盘还应该能够产生如下有意义，但不要求的的字符。对这些字符的实际代码指派在TELNET命令一节中，因为它们被作为普通的应该被提供的，即使在数据流被解释为一些其它字符集的情况下。

Synch 此键允许用户清除到另一方的数据通道。此键的激活导致DM的发送，而且还导致同时发送TCP的紧急信号。DM-紧急信号对有如前面定义的意义。

Break (BRK) 它的提供是因为它不是ASCII字符集内的一员。它指示Break键和Attention键被按下。然而，请注意：它是作为第129个代码，而不是IP标准定义。

Interrupt Process (IP) 暂停，中断，放弃或终止NVT连接的进程的执行。同样的，它也是使用TELNET协议的协议要使用的信号。

Abort Output (AO) 允许当前进程运行至终止，但不将结果送给用户。同样，发送SYNCH给用户。

Are You There (AYT) 回送给NVT一些可见的字符。

Erase Character (EC) 接收方应该删除紧后一个未删除的字符或从数据流中删除一个“显示位置”。

Erase Line (EL) 接收方应该将数据流中的字符从当前位置开始一直删除到最近的“CR LF”为止。

这些“额外”键的功能和一些显示格式功能键是它们应该代表一个对从NVT到本地机映射的扩充。如同NVT数据字节68应该被映射为大写D一样，一个EC字符应该被映射为一个“删除行”的功能键。另外，如果映射124在一些情况下是武断的一样，EL字符的映射有时候也是武断的。对于格式字符也是一样的：如果终端实际上拥有“垂直制表位”，那么映射到NVT是显然的，如果终端不提供此功能，那么结果将是不可预料的。TELNET命令结构 所有TELNET命令结构至少包括一个两个字节的序列：由一个IAC后跟一个命令。关于选项会话的命令是由三个字节的序列构成的，第三个字节是关于选项参考的。选择这种结构，这样随着完全使用数据空格数据与命令值之间的冲突就会减少，所有这些冲突导致了不一致和没有效率和数据的丢失。根据目前的设置，只有与IAC冲突的数据需要被发送两次，其它255个代码都可以直接发送。下面是定义了的TELNET命令。注意：只有当代码和代码序列前面是IAC时它才是命令。

SE 240 结束子会话参数。

NOP 241 无操作。

Data Mark 242 Synch的数据流部分。这应该总和TCP紧急标志一起发送。

Break 243 NVT 字符 BRK。

Interrupt Process 244 IP功能。

Abort output 245 AO功能。

Are You There 246 AYT功能。

Erase character 247 EC功能。

Erase character 247 EL功能。

Go ahead 249 The GA 信号。

SB 250 指出所跟随的是指示选项的子对话。

WILL (option code) 251 指示希望开始执行，或者确认现在正在操作指示的选项。

WON'T (option code) 252 指出拒绝执行或继续招待所指示的选项。

DO (option code) 253 指出要求对方执行，或者确认希望对方执行指示的选项。

DON'T (option code) 254 指出要求对方停止执行，或者确诊要求对方停止执行指示的选项。

IAC 255 数据字节 255。

　

　

建立连接

TELNET TCP连接在用户端口U和服务器端口L之间建立。服务器在这个公认的端口上等待连接。因为TCP连接是一个全双工的，由双方端口共同确认，服务器可以同时在L端口同时处理许多来自不同U端口的连接。端口的指定 当用于远程用户访问服务主机，此协议指定端口23（也就是八进制的27）。那是 L = 23。
 
















==========================================================================================================
==========================================================================================================
==========================================================================================================

组织：中国互动出版网（http://www.china-pub.com/）
RFC文档中文翻译计划（http://www.china-pub.com/compters/emook/aboutemook.htm）
E-mail：ouyang@china-pub.com
译者： 
译文发布时间：2001-10-20
版权：本中文翻译文档版权归中国互动出版网所有。可以用于非商业用途自由转载，但必须
保留本文档的翻译及版权信息。



Network Working Group                                          J. Postel
Request for Comments: 854                                    J. Reynolds
                                                                     ISI
Obsoletes: NIC 18639                                            May 1983


TELNET协议规范
(RFC874――TELNET PROTOCOL SPECIFICATION)

本RFC指定了一个ARPA互联网社区的标准。在ARPA互联网上的主机应该采纳与实
现该标准。
目录
简介	1
一般性的考虑	1
网络虚终端	4
数据的传输	4
控制功能的标准表示	5
TELNET中的“同步（SYNCH）"信号	7
NVT打印机和键盘	8
TELNET命令结构	11

简介
TELNET协议的目的是提供一个相对通用的，双向的，面向八位字节的通信机制。它的主要
目标是允许界面终端设备和面向终端的过程能通过一个标准过程进行互相交互。另外，可以
预想，该协议可以应用到终端到终端通信(“连接”)和过程到过程通信(分布计算)中。
一般性的考虑
一个TELNET连接就是一个用来传输带有TELNET控制信息数据的传输控制协议(TCP)的
连接。

TELNET协议的建立基于这样三个主要想法:一，网络虚终端的概念;二，可谈判的选项
的原理;三，对终端和过程进行均衡看待的观点。

1．一旦一个TELNET连接建立后，通信的两端被假设为在一个”网络虚拟终端”，或
者NVT上开始和终止操作。一个NVT可以被想象为一个能提供标准的，网络范围的规范终
端的中间代表者。这消除了”服务者”和”用户”之间需要保存对方终端和终端处理协定的
信息的必要。所有的主机，包括用户和服务器，把他们本地的设备属性和协定映射为就象一
个在网络上的NVT，而且每一方都可以假设对方也有一个类似的映射。NVT有意地使过度
受限(没有提供给主机足够的词汇来映射到他们的本地字符集)和过度包含(使用适当的终止
来处罚用户)达到了平衡。

    注意:”用户”机通常指那些进行连接的物理终端，”服务器”提出指的是那些能够提供
一些服务的机器。从终端到终端或过程到过程的可应用的平等性来看，”用户”指的是初始
化通信连接的机器。

2．可谈判的选项的观点基于这样一个事实:许多主机都希望能够在NVT之上提供更多
的服务，而许多用户将会拥有一个更复杂的终端，并且希望能够得到一流的，而不是极少的
一点服务。尽管相互独立，但建立在TELNET协议中的是许许多多的”选项”，这些选项将
被用来认可及同”DO,DON’T,WILL,WON’T”结构(下面将会讨论)一起使用去允许用户
和服务器同意在他们的TELNET连接上使用更精致的(或者可能是完全不同的)协议集合。这
些选项包括改变字符集，回显，等等。
  
建立选项使用的基本策略，是让每一方(或双方)初始化一个使一些选项有效的请求，另
一方可以接受或拒绝该请求。如果该请求被接受了，选项立即生效;如果该请求被拒绝，连
接的另一端仍然保留NVT的特性。很显然，一方经常可以通过拒绝来使能，而从来不能通
过拒绝来取消一些选项，因为这些选项是双方为了支持NVT而准备的。

我们已经建立了一套谈判选项的规则，使得双方在同时请求一个相同选项的时候，每一
方都可以把对方的请求当作对自己的请求的肯定回应。

3．谈判句法的对称性可能会导致无穷尽的应答循环--每一方都把对方发送过来的命令
当作必须回答的请求而不是对方的应答。为防止这种循环，可以应用下面这些规则:

a．一方只能请求改变选项的状态。也就是一方不能只发送宣布它所使用的模式的请求。

b．如果一方所接收到的请求是要求它进入当前它所在的状态，那么该请求将不会被应
答。这种不应答对防止无穷尽的循环是非常重要的。对于那些改变模式的请求，都需要一个
应答--尽管该模式不一定改变。

C．无论何时，只要一方向第二方发送一个选项命令，不管该命令是请求还是应答，而
且使用该选项将会对从第一方发送到第二方的数据进行处理时生产影响，那么必须把该命令
插到数据流中它希望开始起作用的点上。(要注意到在传送请求和接收到可能是否定的应答
的过程需要一些时间。因此，一台主机可能在发出请求一个选项的请求后希望缓冲要发送的
数据，直到它知道该请求是被接受还是被拒绝，来隐藏这段对用户来说是"不确定"的时间。)

选项请求在TELENT连接刚刚建立起的时候要在在连接的两端来来回回传送许多次，
每一方都试图从对方获取尽可能好的服务。然而，在另一方面，选项可以用来动态地改变连
接的特性，使它与对本地状态的改变相一致。例如，NVT(后面将要解释)使用的传输方式比
较适合一个用BASIC语言编的应用，这类应用在传输数据时是每次一行，而对那些每次传
输一个字符的应用(比如NLS)就不是很适合。当对本地的处理来说是合适的，一个服务器可
能会忍受这种“临时的特征”所需的巨大的处理器开销，并且会谈判一个合适的选项。然而，
当不再需要详尽的控制时，处理开销可以（通过谈判）切换回NVT下的状态。

如果一个过程在收到一个拒绝回应后，仅仅是重新请求该选项，那么由一个过程发起的
请求将会导致不停的请求循环。 为了防止出现这样的循环，不能重复被拒绝的请求，除非
已经改变了某些选项。在运行中，这可能意味着该过程运行一个不同的程序，或者用户已经
发出了另外的命令，或者出现了其他所有可以影响一个过程及其选项的上下文的东西。根据
经验，重新请求只能是一个连接的另外一端在后来又提交了某些信息，或者本地用户的交互
的需要。

选项的设计者不应该拘泥于选项谈判中有限的一些语法。使用简单的语法的本意是希望
使得选项易于使用 C 因为要忽略它们是很容易的。如果有一些特殊的选项需要一个比
“DO,DON’T,WILL,WON’T”更完整的谈判结构，一个比较好的方法是用"DO, DON'T, 
WILL, WON'T"使双方都能理解该选项，一旦这个过程已经完成，就可以自由地使用一个更
为特别的语法。比如，一方可以发送一个请求来通知（建立）一行的长度。如果这个请求被
另一方所接受，那么可以用另外一个不同的语法来进行实际的对一行的长度的谈判 C 如一
个”子谈判“可能包括可以允许的最小值，可以允许的最大值，以及最合适的行的长度等字
段。一个较为重要的原理是，这样的扩展谈判只有在前面的一些（标准）谈判已经建立，并
且双方都可以解释这些扩展语法的情况下才能开始。

总之，WILL XXX由双方发送出去，表示该方希望（提出）开始对选项XXX进行处理。
DO XXX和DON'T XXX表示它的肯定和否定回应；类似地，DO XXX发送出去指示（请求）
对方（也即DO的接收者）开始对选项XXX进行处理，WILL XXX和WON'T XXX表示肯
定和否定回应。

由于在没有使用任何的选项的情况下，NVT通过使用DON'T和WON'T回应来保证连
接在连接的双方都可以处理的状态中。因此，所有主机都应该这样实现它们的TELNET进
程：在完全不知道一个不支持的选项的情况下，只需要简单地拒绝任何无法了解的该选项请
求。

TELNET协议尽可能地使服务器和用户之间是对称的，以便比较容易和自然地包含用
户到用户（连接）和服务器到服务器（协作处理）这两种情况。尽管不是完全需要，但我们
也希望选项能够加强这个目的。在任何情况下，我们更倾向于明确承认对称性是一个操作上
的原则，而不是一个不变的标准。
请参考相关文档“TELNET选项规范”来得到关于如何建立新的选项的信息。
网络虚终端
网络虚终端（NVT）是一个双向的字符设备。NVT有一个打印机和一个键盘。打印机
负责进来的数据，而键盘负责产生通过TELNET连接发送出去的数据，并且在需要"回显“时，
同时在NVT的打印机上回显这些数据。”回显“并不要求数据一定要经过网络（尽管有一个
选项可以控制该操作的”远程“模式，但并不要求主机实现该选项）。

除了在这里说明的外，所有的编码集合都是有八位的，但只使用其中的七位的USASCII
码。所有的代码转换和时区方面的问题都是本地的事情，而不影响NVT。
数据的传输
尽管一个通过网络连接的TELNET连接本质上是全双工的，但通常把NVT看作在线性
缓冲模式下的半双工设备。也就是说，除非已经和对方谈判好，以下情形 对应于通过
TELNET连接进行数据传输。

1) 在本地缓冲空间允许的可用范围内，可以在产生数据的机器上汇集数据，直到完整的一
行数据已经准备好传输，或者某些在局部定义的信号明确地要求传输数据。这些信号既可以
有进程产生，也可以有用户发出。

定义这个规则的动机是，对于一些主机，处理网络输入中断的代价是很高的，另外，缺省的
NVT规范指定“回显”操作的数据不经过网络的传输。因此，有理由在产生数据的源上缓
冲一些数据。许多系统都会在输入一行结束后进行一些动作（行式打印机或者卡片打孔机经
常都是这样子的），因此数据传输可以在一行数据结束时触发。另外，有时候一个用户或者
进程会发现有必要或者应该提供一些不在一行的结尾结束的数据；因此实现者要注意，提供
的局部信号机制要确保所有的缓冲数据都能够被立即发送出去。

 2) 当一个过程已完成向一个NVT打印机发送数据，并且输入队列中也没有来自NVT键盘，
需要进一步进行处理的数据（就是说，当一个在TELNET连接的一端的过程无法在另一端
没有数据输入的情况下进行处理），该过程必须传输TELNET 的继续（Go Ahead,GA）命
令。

这个规则并不要求在一个连接的两端上的终端都发送TELNET GA命令，因为服务器
开始进行处理时，一般情况下都不需要一个特别的信号（以及断开连接信号和其他在本地定
义的特性）。况且，TELNET GA被设计来帮助一个具有“可锁定”键盘的本地计算机（如
IBM2741）建立一个物理上的半双工终端。这种终端的一个说明可能对解释GA命令的正确
用法有帮助。

终端到计算机的连接总是在用户或者计算机的控制之下。任何一方都不能单方面地夺取
另一方的控制；而且取得控制的一方必须明确地放弃它地控制。在终端这一方，硬件上就支
持在每次一个“连接”终止的时候（也就是在用户按下“新连接”的键时），它就放弃控制。 
当这种情况发生时，连接的（本地）计算机处理输入的数据，决定是否要产生输出，如果不
需要的话，就把控制返回给终端。如果要产生输出，计算机维持控制，直到所有的输出都被
传输完毕。 

通过网络使用这种类型的终端，困难是显而易见的。“本地”计算机在看到一个结束连
线信号后，无法决定是否要保持控制，这个决定只能由处理这些数据的“远程”计算机作出。
因此，TELNET中的GA命令提供了一个机制，使“远程”计算机（服务器）如何给“本地”
计算机（用户）发送信号，告诉对方现在是给用户终端传递控制的时间。当用户需要获得对
终端的控制时，它应该并且只能在这段时间传递。  注意，过早地传递GA命令将导致输出
阻塞，由此用户可能会认为传输系统已经被暂停，因此将导致用户手工转向连接时失败。

当然，前面所说的这种情况不会在通讯过程中用户到服务器这个方向上出现。在这个方
向上，尽管没有必要，但在任何时候都可能发送出GA。同样，如果TELNET连接被应用在
过程到过程的通讯中，在两个方向上都不需要发送GA。最后，对于终端到终端的通讯，在
两个方向上可能都需要GA。如果一个主机打算支持终端到终端的通讯，建议主机在需要通
过TELNET连接发送GA的时候，提供一个手工发信号给用户的方法。然而，在实现TELNET
过程中，这一点并不是必需的。

注意：由于TELNET模型的对称性，从理论上来说，在一个TELNET连接的每一端，都必
须有一个NVT。
控制功能的标准表示
就象我们在本文档的简介中所说，TELENT协议的主要目标是在通过网络连接的终端
设备和面向终端的过程之间提供一个标准的接口。早期具有这种互联性质的实验表明，大部
分的服务器都实现了某些功能，但调用这些功能的方式却差别很大。对于一个要与多个服务
器系统交互的用户来说，这些差别是一个非常大的障碍。因此，TELNET协议定义了这些
功能中的下面5种的标准表示。这些标准表示包括标准，含义 --- 尽管不是必需的（除了
中断进程（IP）功能，使用TELENT协议的其他协议可能需要该功能）。因此，一个没有给
本地用户提供某种功能的系统也没有必要给网络上的其他用户提供该功能，并且可以把该功
能的标准表示当作No操作。在另一方面，如果一个系统已经给本地用户提供了该功能，那
么它必须给网络上那些传该功能的标准表示的用户提供同样的功能。

中断进程 C Interrupted Process(IP)

许多系统提供挂起，中断，中止，终止用户进程的操作的功能。当用户确信他的进程已
经进入了无穷尽的循环，或者不小心激活了一个并不希望激活的进程时，就要经常使用该功
能。IP就是调用该功能的标准表示。该功能的实现者需要注意，其他使用TELNET协议的
协议可能要使用IP，因此实现时要支持这些协议。

 中断输出 -- Abort Output (AO)

   许多系统提供了允许一个产生输出的进程在不向用户的终端发送输出的情况下完成运行
（或者达到在完成运行的过程中将会达到的某一个停止点）的功能。
 另外，该功能一般还清除那些已经生成但还没有实际打印（或者显示）到用户的终端上的
输出。AO是调用该功能的标准表示。 比如，许多子系统通常会接受一个用户的命令，然
后以一个发送到用户终端的长的字符串作为回应，最后，给用户的终端发送一个“提示”字
符（前面跟着<CR><LF>）来表示准备接受下一个命令。如果是在传输字符串的过程中接收
到AO，一个合理的实现应该停止继续传输字符串，而转向发送提示符和跟在前面的
<CR><LF>。（这可能同接收到IP所进行的动作有一些差别。在接收到IP时，将导致停止
字符串的传输并且从子系统中退出。

同时还需要注意到，对那些提供这种功能的服务器，可能还需要清除那些存在于系统外
的缓冲机制（在网络中或者在用户的本地机器上）中的内容。完成这个过程的一个合适的方
法是给用户的系统发送“同步”信号（将在下面描述）。

你在那里吗？ --  Are You There (AYT)

许多系统提供了给用户提供系统仍然在运行的一些可见的（如可打印的）迹象。这个功
能可以在系统在一个想象不到的很长一段时间里都没有动静时（可能是由于用户没有想象到
的计算时间，或者不正常的巨大系统负荷等导致。）由用户调用。 AYT是调用该功能的标
准表示.

消除一个字符 - - Erase Character (EC)

许多系统提供了删除在未删除字符前面或者用户提供的数据流中的“打印位置” 最后
面的一个字符的功能。该功能通常在键盘输入时输入了错误的字符时使用。EC是调用该功
能的标准表示。

*注意 ：一个“打印位置”可能包含相互覆盖的几个字符，或者象下面的字符系列：
<char1> BS <char2>...

消除一行 -- Erase Line (EL)     

许多系统提供了删除输出设备上的当前一行的全部数据的功能。该功能经常在用键盘进
行输入编辑时使用。EL是调用该功能的标准表示。
TELNET中的“同步（SYNCH）"信号
许多系统提供了一种机制，可以允许一个终端的用户对一个“失控“的进程重新获得控
制权。上面描述的IP和AO功能就是这种机制的例子。当在本地使用时，这样的系统可以
访问由用户提供的所有信号，而不管这些信号是一些普通字符或者是由电传打字机中的
"BREAK"键或IBM 2741中的"ATTN"键发送的”带外“信号。然而当通过网络把系统联结
起来时，这可能是不正确的。网络的流程控制机制可能导致把这些信号缓冲到其他地方，比
如用户的机器中。

为了解决这个问题，提出了TELNET中的"同步" 机制。
一个同步信号包含一个同TELNET命令DATA MARK结合在一起的TCP紧急通知。该
紧急通知与TELNET连接中的流程控制没有关系，接收它的进程用它来调用数据流的特殊
处理过程。在这种模式中，立即对数据流进行扫描，查找下面定义的一些“有趣“的信号，
而把那些干涉的数据丢弃。

TELNET命令DATA MARK (DM)是数据流中的同步标记，表示所有特殊的信号都已经
产生，接受者可以继续对数据流进行一般的处理。

同步信号通过TCP中的发送操作发送，在发送过程中需要把紧急标志设为“真“，并
且把DM作为最后（或者唯一的）一个字节。

当许多同步信号快速地连续不断地发送时，可以合并紧急通知。不可能去计算紧急通知
的次数，因为接收到的紧急通知的次数可能等于或者少于发送次数。在普通模式中，一个
DM是没有任何操作的，但在紧急模式中，它表示紧急处理过程的结束。

如果在发现DM之前，TCP已经指示紧急数据的结束，TELNET应该继续对数据流进
行特殊的处理，直到发现DM。

如果在发现DM之后，TCP指示有更多的紧急数据，它只能是另外同步信号。TELNET
应该继续对数据流进行特殊的处理，直到发现另外一个DM。

定义的“有趣的“信号为：TELNET中的IP， AO， 和 AYT (没有EC 或EL)的标准
表示;与这些标准表示类似的本地表示（如果有的话）；所有的其他TELNET命令；其他在
不延迟数据流的扫描并且能够起作用的自定义信号。

由于SYNCH机制的一个影响是丢弃本来在发送者和接收者之间要传输的所有字符（除
了TELNET命令），如果需要，这个机制可以作为清除数据路径的一种标准方式。例如，在
一个终端上的用户需要传输一个AO，接收到该AO的服务器应该给该用户返回一个同步信
号（如果它提供该功能的话）。

最后，就象在TELNET层，需要把一个TCP紧急通知当作一个带外信号，因此其他使
用TELNET的协议可能需要从不同层次来看可以当作带外信号的TELNET命令。

通过约定系列[IP, Synch] 可以把它作为这样的信号。例如，假设有一个使用
	TELNET协议的其他协议定义了一个类似于TELNET命令AO的字符串STOP。想象
用户使用该协议的目的是希望服务器处理STOP字符串，但由于服务器在处理其他的命令，
导致连接被阻塞。用户应该引导他的系统：

a)	发送出TELNET IP字符；

b)	发送出TELNET SYNC系列，也就是：在一个紧急模式的TCP发送操作中把Data Mark 
(DM)作为唯一的字符发送出去。

c)	发送出字符串STOP；接着

d)	如果有的话，把其他协议中类似于TELNET DM的命令发送出去。
 
用户（或者代表该用户的进程）必须传输上面步骤2中的TELNET SYNCH 系列，以确保
TELNET IP已经到达服务器的TELNET 解释器。

紧急通知将激活TELNET进程，而IP将激活随后级别较高的进程。
NVT打印机和键盘
NVT打印机有一个没有指定宽度的走纸器，并且每一页的长度也没有指定。NVT打印
机可以产生所有95个USASCII编码的图形表示（从32到126的编码）。在33个USASCII
编码（0到31及127）和未包含的其他128个编码（128到255）中，下面几个编码对NVT
打印机有确定意义：

         名称                  编码         意义

         NULL (NUL)             0         没有操作
         Line Feed (LF)         10         打印头移到下一个打印行，但不改变打印
头的水平位置。
         Carriage Return (CR)    13         把打印头移到当前行的左边 。


另外，在NVT打印机上，尽管不是必需的，同时应该定义下面这些编码。TELNET连
接的双方，都不会假设另一方在接收到或传输下面这些编码时将会，或者已经实施某种特殊
动作：

         BELL (BEL)              7      产生一个可以看到或可以听到的信号（而不
移动打印头。）
         Back Space (BS)         8      向左移动打印头一个字符位置。
         Horizontal Tab (HT)     9      把打印头移到下一个水平制表符停止的位置。
它仍然没有指定每一方如何检测或者设定如
何定位这样的制表符的停止位置。
         Vertical Tab (VT)       11     把打印头移到下一个垂直制表符停止的位置。它
仍然没有指定每一方如何检测或者设定如何
定位这样的制表符的停止位置。

         Form Feed (FF)          12     把打印头移到下一页的顶部，保持打印头在
相同的水平位置上。

剩下的其他编码都不会导致NVT打印实施任何动作。

在定义中，系列"CR LF"将导致NVT打印头移动到下一行的左边（与系列 "LF CR"的
效果是一样的）。然而，许多系统和终端并不独立处理CR和LF，为了模拟它们的效果，需
要进行一些处理。 （比如，许多终端没有独立于LF的CR，但是在这样的终端上可以用退
格键来模拟一个CR。）因此，必须把系列CR LF"当作一个单独的“新行”字符看待，并且
在需要把它们结合在一起的时候使用它们。必须在只需要一个单独的回车键时使用系列"CR 
NUL"；在其他的场境中必须避免使用CR字符。这个规则可以确保系统在发现一个TELNET
流中有一个字符的后面跟有CR的情况下，可以作出合理的选择：是进行“换行”功能还是
进行多次的退格操作。

    注意，在两个方向上（在缺省的ASCII模式下）都需要"CR LF"或者"CR NUL"，以确
保NVT模式的对称性。

尽管在某种情况下（如当远程回显和禁止超前选项同时起作用时），可以认为字符并不
被发送到一个实际的打印机上，然而，为了保证一致，在一个数据流中，如果一个CR的后
面没有跟着一个LF，该协议要求把一个NUL插到CR的后面。
相反，在接收方，如果从数据流中接收到一个跟在CR的后面的NUL（在没有用谈判
选项显式指定其他选择的情况下），在把NVT转换成本地字符集之前，应该把NUL去掉。

    NVT键盘有键或者键的组合，或者键系列来产生所有128格USAACII编码。要注意尽
管一些在NVT打印机上没有什么用处，NVT键盘还是可以生成。

    除了这些编码，NVT键盘还可以生成下面这些附加的编码，除注明外，还定义了这些
编码的意义（尽管不是必需的）。

对这些“字符”的实际代码分配在TELNET命令这一节，因为从某种意义上来讲，我
们可以认为这些编码是固有的，甚至在把数据流中的数据都解释为属于另外的一个字符集的
时候，都可以使用这些编码。

Synch

这个键允许一个用户清空到另一方的数据通道。激活该键将导致发送一个带有TCP紧
急通知的DM（参看命令这一节）。一对DM-紧急通知具有在前面定义的一些意义。

Break (BRK)

之所以提供这个编码，是因为在当前的许多系统中，它是USASCII集合之外的一个
信号，并且具有本地意义。 可以用它来表示Break键或Attention键已被按下。然而，需
要注意的是，它的目的是给需要它的系统提供第129个编码，而不等同于IP的标准表示。

Interrupt Process (IP)

挂起，中断，中止，终止一个NVT连接的进程。另外，它也是那些使用TELNET的其他协
议的带外信号的一部分。

Abort Output (AO)

   允许当前的进程继续运行直到结束，但不给用户发送它的输出信息。并且把一个同步信
号发送给用户。

Are You There (AYT)

给NVT发送回一些可见的（也就是可打印的）信息以表明已经收到AYT。

Erase Character (EC)

接收者将删除数据流中最后一个未被删除的前导字符或者“打印位置”。

Erase Line (EL)

接收方将删除由TELNET连接发送的数据流中最后一个“CR LF”系列（但不包括该系列）
后面的全部内容。

    这些“额外”的键，也就是打印机的格式控制字符的本质是，它们是对从“NVT”到“本
地”这个必须进行的映射过程的一个自然的扩展。

就象NVT中的字节68（八进制104），可以映射为本地中代表“大写D”的任何一个编码，
字符EC也可以映射为本地中代表“删除一个字符”功能。

另外，就象在一个没有“垂直线”字符的环境下，对编码124（八进制174）的映射是
任意的，如果在本地没有“删除一个字符”这种机制，对EL的映射也是任意的（甚至不映
射）。

类似地，对格式控制字符，如果终端确实有一个“垂直制表键”，那么对VT地映射就
是显而易见的，只有在终端没有一个垂直制表键的情况下，VT的作用才是无法预测的。
TELNET命令结构
    所有的TELNET命令至少包含一个两个字节的序列:跟在命令的代码的后面，"当作命令
来解释(Interpret as Command)"(IAC)的转义字符。处理选项谈判的命令有三个字节系列，
第三个字节就成了被选项引用的编码。之所以选择这种格式，是这种格式能够更大范围地使
用"数据空间"---当然，是通过基本NVT的谈判来进行。数据字节与保留的命令值的冲突被
大大减少了，而所有这些冲突都需要复杂，低效的方法来把数据字节转换为流。使用现在的
方法，只有在需要把IAC当作数据发送时才需要把相同的数据发送两次，其他255个代码
都可以透明地传输。

下面是所有已定义的TELNET命令。需要注意的是，这些代码和代码序列只有在前面
跟有一个IAC时才有意义。

      名称                     代码                     意义

SE                             240                子谈判参数的结束
NOP                          241                空操作
Data Mark                     242                  一个同步信号的数据流部分。该
命令的后面经常跟着一个TCP紧急
通知
Break                        243                NVT的BRK字符
Interrupt Process              244                    IP功能.
Abort output                245                AO功能.
Are You There             246                AYT功能.
Erase character            247                EC功能.
Erase Line                248                EL功能.
Go ahead                  249               GA信号.
SB                        250               表示后面所跟的是对需要的选项的子谈
判
WILL (option code)         251               表示希望开始使用或者确认所使用的是
指定的选项。
WON'T (option code)        252            表示拒绝使用或者继续使用指定的选项。
DO (option code)            253                表示一方要求另一方使用，或者确认
你希望另一方使用指定的选项。
DON'T (option code)          254             表示一方要求另一方停止使用，或者确
认你不再希望另一方使用指定的选项。 
IAC                         255            Data Byte 255.

连接的建立

TELNET TCP连接是在用户端口U和服务器端口L之间建立的。服务器在用于这种类型的
连接的一个众所周知的端口L上监听客户请求。由于一个TPC连接是全双工的，并且通过
双方的端口来标识，服务器可以对不同的用户端口U和端口L的之间的许多并发连接进行
应答。

端口分配

当用来给远程用户提供访问服务主机的服务(也就是远程终端访问)，这个协议分配了服务端
口23(把进制27)。也就是L=23。

    本RFC指定了一个ARPA互联网社区的标准。在ARPA互联网上的主机应该采纳与实
现该标准。

    给TELNET协议提供一些选项的目的是，使相互通信的主机在解决不同设备之间的通
信问题时获得比由网络虚拟终端（NVT）提供的可能框架有更好的方案。它可以让主机自由
地创建，测试或者丢弃某些选项。当然，可以想象，那些普遍有用的选项最终大部分的主机
都应该支持。因此，应该仔细地设计这些选项的文档，并且尽可能地公布它们。另外，确保
不在不同地选项中使用相同的选项代码也是必要的。

本文档指定了一个选项代码的分配和选项的文档标准方面的方法。在进行试验时，可能只需
要选项代码分配而不需要完整的文档，不过一般来说，在分配选项代码之前都需要一个文档。
我们通过把一个选项的文档作为一个RFC文档来发布，从而发布该选项。当然，选项的创
建者也可以用其他的方式发布选项。

    选项代码由下面人员分配：
      Jonathan B。 Postel
      University of Southern California
      Information Sciences Institute (USC-ISI)
      4676 Admiralty Way
      Marina Del Rey, California 90291
      (213) 822-1511

      Mailbox = POSTEL@USC-ISIF

选项的文档至少要包含下面几个小节：

第1节 - - 命令的名称和选项的代码

第2节 - - 命令的意义

    应该描述同该选项相关的每一个TELNET命令的意义。需要注意的是，对于复杂的选
项，“子谈判”是必需的，因此可能有许多相关的命令。“子谈判”的原理在下面有更详细的
描述。

第3节 - 缺省的规范

    对那些没有实现，或者没有使用该选项的主机，必须描述这些选项在这些主机中的缺省
假定值。

第4节 - 动机

    对创建一个特殊的选项，或者对某种选项选择一种特殊的格式的动机进行详细的描述，
对那些还没有碰到（或者虽然已经碰到，但没有认识到）该选项设计来解决的问题的人，是
非常有用的。

第5节 - 描述（或者实现规则）

为了确保一个命令的两个不同实现相互之间能够通讯，仅仅定义命令的意义和对该命令的意
图进行说明有时候是远远不够的。因此，在许多情况下，我们需要给一个命令提供一个完整
的描述。这个描述可以用文本来表示，也可以是一个示例性的实现，或者是实现的线索等等。

对“子谈判”的解释

在主机之间传递选项时，除了一个选项编码外可能还需要更多其他信息。例如，要求一个参
数的那些选项就属于这种情况。在主机之间传递除了选项代码外的其他信息的策略包含两个
步骤：双方都同意去”商讨“该参数，第二，对参数进行”商讨“。

在第一步中，同意去讨论参数以一种普通的方式来进行。一方通过发送一个带有选项代码的
DO(或WILL)命令来建议使用选项，另一方发送一个带有选项代码的DO(或WILL)命令来表
示接受这个建议。一旦双方都同意使用这选项，通过在SB命令的后面跟上相应的选项代码，
参数和命令SE来开始子谈判。每一方都被假设为能够解析该参数。因为在最初通过交换
WILL和DO命令，双方都表明可以支持该选项。另外，即使接收方不能解析该参数，接收
方也可以通过搜索SE命令（如字符串IAC SE）来定位参数字符串的结束位置。当然，在
任何时候，任何一方都可以给另一方发送WON'T或DON'T来拒绝继续进行进一步的子谈
判。
     

Rfc845---TELNET PROTOCOL SPECIFICATION                               TELNET协议规范


10
RFC文档中文翻译计划			


=========================================================================================================
=========================================================================================================
=========================================================================================================
=========================================================================================================


Network Working Group                                     Marvin Solomon 
Request for Comments: 930                                 Edward Wimmers 
Supersedes: RFC 884                    University of Wisconsin - Madison 
                                                            January 1985 
Telnet终端类型选项 
（RFC930――Telnet Terminal Type Option） 
   
本备忘录的状态 

本RFC规范了一个ARPA Internet community上的标准。在ARPA Internet上的所有主机应当采用和实现这个标准。本文的发布不受任何限制。 
本标准是对RFC884的更新。唯一的变化是定义了TERMINAL-TYPE  IS子谈判只能在对TERMINAL-TYPE  SEND子谈判作出回应时送出。详文见下。 

1．命令和代码 

TERMINAL    24 

2．命令意义 

IAC　WILL　TERMINAL-TYPE 
发送端可在一个后续子谈判中发送终端信息。 
IAC　WON’T　TERMINAL-TYPE 
发送端拒绝发送终端信息。 
IAC　DO　TERMINAL　-TYPE 
发送端可在一个后续子谈判中接收终端信息。 
IAC　DON’T　TERMINAL-TYPE 
发送端拒绝接收终端类型信息。 
IAC　SB　TEMINAL-TYPE　SEND　IAC　SE 
发送端请求接受端将其终端类型传给自己。SEND的命令码是１。（见下） 
IAC　SB　TERMINAL-TYPE　IS　　　IAC　SE 
发送端正在声明其终端类型。此命令的代码是０。（见下） 

３．默认值 

WON’T　TERMINAL-TYPE 
终端类型信息不变。 
DON’T　TERMINAL-TYPE 
终端类型信息不便。 

４．选项产生的原因 

这个选项能够允许telnet服务器确认已连接到用户telnet程序的终端类型。类型信息的传输并不意味着处理过程会马上变化，这些信息可能传递给一个过程，这个过程对其为适应特定终端类型所发出的数据给以警告。例如，某些操作系统有终端驱动程序，所以可以接受用来表明驱动终端类型的代码。利用TERMANAL　TYPE和BINARY选项，在这些操作系统上的telnet服务器程序就可以驱动客户终端了，而且和直接连接的效果一样，包括鼠标的位置，丰富的颜色等，而这些是没有包括在虚拟网络终端的定义中的。通过推迟向SB命令传送状态信息，这个选项可以和普通TELNET选项的结构保持一致。 

５．选项说明 

WILL和DO只能用于获取和保证将来讨论的许可。实际的状态信息交换与选项子命令同时发生。（IAC　SB　TERMINAL-TYPE）。 
一旦两个主机开始进行WILL和DO的交换，处于DO　TERMINAL-TYPEDE发送端就空闲以备请求类型信息。只有DO类型的发送端端可以发送请求（IAC　SB　TERMINAL-TYPE　SEND　IAC　SE），只有WILL类型的发送端可以传送实际的类型信息（用IAC　SB　RMINAL-TYPE　IS…IAC　SE命令）。终端类型信息不能以自动方式传送，而只能是以请求―响应的方式。 
终端类型信息是NVT　ASCII　String字符串类型。这种编码不考虑大小写的差别。有效终端类型的完整列表可在最近的RFC“Assigned　Numbers”找到。 
接下来是一个选项应用的例子： 
主机１：IAC　DO　TERMINAL-TYPE 
主机２：IAC　WILL　TERMINAL-TYPE 
（主机１可随时请求状态信息） 
主机１：IAC　SB　TERMINAL-TYPE　SEND　IAC　SE 
主机２：IAC　SB　TERMINAL-TYPE　IS　IBM-３７２８-２　IAC　SE 

６．实现 

“终端类型”信息可以是任何对谈判双方有意义的NVT　ASCII　字符串。在“Assigned　Number”中命名的终端类型表是用来降低由终端类型名称多样所引起的混乱。例如，如果一个终端被一部分人叫作“IBM3278-2”型，而另一部分人称其为“IBM3278／2”，在这个时侯就产生了混乱。对于终端类型未知的情况，是不能作出否定确认的，但是在有效终端类型名还未被确认的情况下，一些其他选项（如转换到BINARY模式）可能会被拒绝。在某些情况下，一个特定的终端可能会有不止一个名字，即一个特定类型可能对应于多个普通类型。在这些情况下，TERMINAL-TYPE　IS命令可能会用很多不同的名字来回应连续的TERMINAL-TYPE　SEND命令。而在这种方式下，不明白第一次相应的telnet服务器会要求终端重发。然而如果服务器两次都收到了同样的响应，它就停止发送TERMINAL-TYPE　SEND命令。同样的，发送端应该用重复前一个类型名的方法表明它已经将所有有效的类型名发送完毕。注意：TERMINAL-TYPE　SEND命令在回应请求（TERMINAL-TYPE　SEND），这是因为发送TERMINAL-TYPE　SEND和接收TERMINAL-TYPE　SEND的主机不能确定其他主机是正在请求第二个选项，还是TERMINAL-TYPE　SEND和TERMINAL-TYPE　IS两个命令在中途混淆了。 
“UNKNOWN”类型可被用于当终端类型不确定或不可能被其他人认出的情况。 
在“Assigned　Numbers”中保持着完整并且是最新的终端类型名。终端类型名的最大长度为４０个字符。


========================================================================================================
========================================================================================================
========================================================================================================


#define NUL     0
#define BEL     7
#define BS      8
#define HT      9
#define LF     10
#define VT     11
#define FF     12
#define CR     13
#define SE    240
#define NOP   241
#define DM    242
#define BRK   243
#define IP    244
#define AO    245
#define AYT   246
#define EC    247
#define EL    248
#define GA    249
#define SB    250
#define WILL  251
#define WONT  252
#define DO    253
#define DONT  254
#define IAC   255.
enum _verb
{
  verb_sb   = 250,
  verb_will = 251,
  verb_wont = 252,
  verb_do   = 253, 
  verb_dont = 254
};
enum _state
{
  state_data,   //we expect a data byte
  state_code,   //we expect a code
  state_option  //we expect an option
};
enum _option
{
  TOPT_BIN = 0,   // Binary Transmission
  TOPT_ECHO = 1,  // Echo
  TOPT_RECN = 2,  // Reconnection
  TOPT_SUPP = 3,  // Suppress Go Ahead
  TOPT_APRX = 4,  // Approx Message Size Negotiation
  TOPT_STAT = 5,  // Status
  TOPT_TIM = 6,   // Timing Mark
  TOPT_REM = 7,   // Remote Controlled Trans and Echo
  TOPT_OLW = 8,   // Output Line Width
  TOPT_OPS = 9,   // Output Page Size
  TOPT_OCRD = 10, // Output Carriage-Return Disposition
  TOPT_OHT = 11,  // Output Horizontal Tabstops
  TOPT_OHTD = 12, // Output Horizontal Tab Disposition
  TOPT_OFD = 13,  // Output Formfeed Disposition
  TOPT_OVT = 14,  // Output Vertical Tabstops
  TOPT_OVTD = 15, // Output Vertical Tab Disposition
  TOPT_OLD = 16,  // Output Linefeed Disposition
  TOPT_EXT = 17,  // Extended ASCII
  TOPT_LOGO = 18, // Logout
  TOPT_BYTE = 19, // Byte Macro
  TOPT_DATA = 20, // Data Entry Terminal
  TOPT_SUP = 21,  // SUPDUP
  TOPT_SUPO = 22, // SUPDUP Output
  TOPT_SNDL = 23, // Send Location
  TOPT_TERM = 24, // Terminal Type
  TOPT_EOR = 25,  // End of Record
  TOPT_TACACS = 26, // TACACS User Identification
  TOPT_OM = 27,   // Output Marking
  TOPT_TLN = 28,  // Terminal Location Number
  TOPT_3270 = 29, // Telnet 3270 Regime
  TOPT_X3 = 30,  // X.3 PAD
  TOPT_NAWS = 31, // Negotiate About Window Size
  TOPT_TS = 32,   // Terminal Speed
  TOPT_RFC = 33,  // Remote Flow Control
  TOPT_LINE = 34, // Linemode
  TOPT_XDL = 35,  // X Display Location
  TOPT_ENVIR = 36,// Telnet Environment Option
  TOPT_AUTH = 37, // Telnet Authentication Option
  TOPT_NENVIR = 39,// Telnet Environment Option
  TOPT_EXTOP = 255, // Extended-Options-List
  TOPT_ERROR = 256  // Magic number
};